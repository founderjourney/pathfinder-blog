---
title: "Sin titulo"
excerpt: "Tenía dos clientes esperando para usar HostelOS en producción. El sistema estaba listo —100+ endpoints, 17 módulos, cero overbookings desde el lanzamiento— pero había un problema fundamental: estaba d"
date: "2025-12-26"
author: "Mauro | Pathfinders Labs"
category: "Architecture"
featuredImage: ""
---

## El Momento de la Verdad

  Tenía dos clientes esperando para usar HostelOS en producción. El sistema estaba listo —100+ endpoints, 17 módulos, cero overbookings desde el lanzamiento— pero había un problema fundamental: **estaba diseñado para un solo hostal**.

  La pregunta parecía simple: ¿cómo hago que múltiples hostales usen el mismo código, cada uno con sus datos aislados?

  Spoiler: la respuesta "obvia" que elegí inicialmente estaba equivocada. Este artículo documenta mi proceso de evaluación, el error que casi cometí, y por qué terminé eligiendo una arquitectura completamente diferente.

  ---

  ## El Contexto: Un PMS Listo para Escalar

  HostelOS es un Property Management System que construí para resolver la fragmentación de canales en hostales pequeños. El stack:

  - **Backend**: Node.js + Express
  - **Base de datos**: SQLite (desarrollo) / PostgreSQL en Neon (producción)
  - **Deploy**: Vercel (serverless)
  - **Seguridad**: RBAC con CASL, Helmet, rate limiting

  El sistema funcionaba. Pero cada tabla —`guests`, `beds`, `bookings`, `transactions`— asumía un único hostal. No había concepto de "este huésped pertenece a este cliente".

  Con dos hostales listos para empezar y la visión de escalar a 50+, necesitaba tomar una decisión arquitectónica que no me hiciera arrepentir en 6 meses.

  ---

  ## Las Tres Opciones que Evalué

  Investigué las estrategias principales de multi-tenancy que usan SaaS B2B en producción:

  ### Opción 1: Database per Tenant (Silo Model)

  Cliente 1 → PostgreSQL DB 1
  Cliente 2 → PostgreSQL DB 2
  Cliente 3 → PostgreSQL DB 3

  **Mi primera intuición fue elegir esta opción.**

  Pros que me atraían:
  - Aislamiento perfecto de datos
  - Fácil cumplir GDPR (backup/delete por cliente)
  - Conceptualmente simple: cada cliente tiene "su" base de datos

  Contras que subestimé:
  - Cada nueva migración = N deploys
  - Connection pooling multiplicado por N
  - Costos que escalan linealmente con clientes

  ### Opción 2: Schema per Tenant

  PostgreSQL DB
  ├── schema_cliente1.guests
  ├── schema_cliente1.beds
  ├── schema_cliente2.guests
  ├── schema_cliente2.beds
  └── ...

  Pros:
  - Buen aislamiento dentro de una DB
  - Un solo backup para todo

  Contras:
  - Solo funciona bien en PostgreSQL
  - Connection pooling limitado por schema
  - Migraciones complejas

  ### Opción 3: Shared Database + Row-Level Security

  PostgreSQL DB
  ├── guests (tenant_id=1, tenant_id=2, ...)
  ├── beds (tenant_id=1, tenant_id=2, ...)
  └── ... todas las tablas con tenant_id

  Pros:
  - Una sola base de datos
  - Una sola migración
  - Costos constantes sin importar número de clientes

  Contras:
  - Requiere disciplina en cada query
  - Riesgo de data leakage si hay bugs

  ---

  ## Mi Error Inicial: Elegir Database per Tenant

  Siendo honesto, mi primera propuesta fue Database per Tenant. El razonamiento parecía sólido:

  > "Solo tengo 2 clientes. Es más fácil manejar 3 bases de datos (training + 2 clientes) que modificar 30+ tablas para agregar tenant_id."

  Diseñé toda la arquitectura:
  - Una DB central para autenticación (tenants, users, sessions)
  - Una DB por cada cliente para datos de negocio
  - Un middleware que resolvía el tenant desde la sesión y conectaba a la DB correcta

  Parecía elegante. Hasta que decidí hacer algo que cambió mi perspectiva por completo.

  ---

  ## El Punto de Inflexión: Consultar a Quienes Ya Resolvieron Este Problema

  Soy Senior Full-Stack Developer, no Senior DevOps. Y cuando enfrento decisiones de infraestructura críticas, tengo una regla: **antes de implementar, consulto a quienes ya cometieron los errores que yo podría cometer**.

  Pasé varias horas investigando:
  - Documentación oficial de PostgreSQL sobre Row-Level Security
  - Discusiones en foros de DevOps y arquitectos de sistemas
  - Posts de ingenieros de empresas como Supabase, Notion y Linear sobre sus decisiones de multi-tenancy
  - Threads en comunidades de YC y Hacker News sobre escalabilidad de SaaS B2B

  El resultado fue brutal. Mi propuesta inicial tenía fallas que no había considerado.

  ### Lo que encontré en esa investigación:

  **Complejidad Operacional**

  Database per Tenant (mi propuesta):
  - 2 clientes = 3 DBs = 3 migraciones por release
  - 50 clientes = 51 DBs = 51 migraciones por release
  - ¿100 clientes? Nightmare operacional.

  **Costos Reales**

  | Modelo | 5 clientes | 50 clientes |
  |--------|-----------|-------------|
  | DB per tenant | ~$50/mes | ~$500/mes |
  | Shared DB + RLS | ~$25/mes | ~$25/mes |

  **Cold Starts en Serverless**

  Vercel tiene cold starts. Cada request necesita establecer conexión a la DB. Con database per tenant, el middleware necesita:
  1. Conectar a DB central para obtener credenciales del tenant
  2. Conectar a DB del tenant para la operación real

  Dos conexiones por request = latencia inaceptable.

  **Cross-tenant Analytics**

  Con databases separadas, responder "¿cuántas reservas procesamos este mes en total?" requiere queries a N bases de datos. Con shared database, es un simple `SELECT COUNT(*)`.

  ### La pregunta que me hizo cambiar de opinión:

  > "¿Qué hacen Notion, Linear, Supabase y la mayoría de SaaS B2B exitosos?"

  Respuesta: **Shared Database con Row-Level Security**.

  No es coincidencia. Es el patrón que mejor escala para SaaS B2B donde los clientes son empresas (no consumidores individuales con datos ultra-sensibles como healthcare).

  ---

  ## La Decisión Final: Row-Level Security de PostgreSQL

  Row-Level Security (RLS) es una feature de PostgreSQL que filtra filas automáticamente basándose en políticas.

  ```sql
  -- Habilitar RLS en la tabla
  ALTER TABLE guests ENABLE ROW LEVEL SECURITY;

  -- Crear política de aislamiento
  CREATE POLICY tenant_isolation ON guests
    USING (tenant_id = current_setting('app.tenant_id')::integer);

  -- En cada request, setear el tenant
  SET app.tenant_id = 2;

  -- Ahora CUALQUIER query está filtrada automáticamente
  SELECT * FROM guests;
  -- PostgreSQL internamente: SELECT * FROM guests WHERE tenant_id = 2

  El beneficio killer: aunque un developer olvide el WHERE tenant_id = ? en una query, PostgreSQL nunca devolverá datos de otro tenant. Es seguridad a nivel de base de datos, no de aplicación.

  ---
  La Arquitectura Final

  ┌─────────────────────────────────────────────────────────────────┐
  │                    hostal-pms.vercel.app                         │
  ├─────────────────────────────────────────────────────────────────┤
  │                                                                  │
  │   ┌──────────────────────────────────────────────────────────┐  │
  │   │              PostgreSQL (Neon) - UNA SOLA DB             │  │
  │   ├──────────────────────────────────────────────────────────┤  │
  │   │                                                          │  │
  │   │  tenants     │ id=1 Training │ id=2 Cliente1 │ id=3 ... │  │
  │   │  ─────────────────────────────────────────────────────── │  │
  │   │  users       │ tenant_id=1   │ tenant_id=2   │ ...      │  │
  │   │  guests      │ tenant_id=1   │ tenant_id=2   │ ...      │  │
  │   │  beds        │ tenant_id=1   │ tenant_id=2   │ ...      │  │
  │   │  bookings    │ tenant_id=1   │ tenant_id=2   │ ...      │  │
  │   │                                                          │  │
  │   │  ┌────────────────────────────────────────────────────┐ │  │
  │   │  │ ROW-LEVEL SECURITY (RLS)                           │ │  │
  │   │  │ PostgreSQL filtra automáticamente por tenant_id    │ │  │
  │   │  │ IMPOSIBLE acceder a datos de otro tenant           │ │  │
  │   │  └────────────────────────────────────────────────────┘ │  │
  │   └──────────────────────────────────────────────────────────┘  │
  │                                                                  │
  └─────────────────────────────────────────────────────────────────┘

  ---
  El Plan de Implementación

  Dividí el trabajo en 2 sprints de 5 días:

  Sprint 1: Schema & Data Foundation
  - Día 1: Crear tabla tenants
  - Día 2-3: Agregar tenant_id a las 30+ tablas
  - Día 4: Crear índices + habilitar RLS
  - Día 5: Migrar datos existentes a tenant_id=1 (Training)

  Sprint 2: Backend Integration
  - Día 6: Middleware de tenant resolution
  - Día 7: Modificar login para incluir tenant en sesión
  - Día 8: Adaptar db-adapter para setear RLS automáticamente
  - Día 9: Testing E2E de aislamiento
  - Día 10: Deploy zero-downtime + scripts de administración

  ---
  Comparación Final: Lo que Casi Hice vs. Lo que Hice

  | Aspecto                  | DB per Tenant (descartada) | Shared DB + RLS (implementada) |
  |--------------------------|----------------------------|--------------------------------|
  | Bases de datos           | N+1                        | 1                              |
  | Migraciones por release  | N                          | 1                              |
  | Costo a 50 clientes      | ~$500/mes                  | ~$25/mes                       |
  | Tiempo de implementación | 60-80 horas                | 15-20 horas                    |
  | Complejidad operacional  | Alta                       | Baja                           |
  | Seguridad de datos       | Por aislamiento físico     | Por RLS (igualmente seguro)    |

  ---
  Lecciones Aprendidas

  1. La solución "obvia" no siempre es la correcta

  Database per tenant suena bien en teoría. En la práctica, es overkill para la mayoría de SaaS B2B. Reserva ese patrón para casos donde el aislamiento físico es un requisito legal (healthcare, fintech regulado).

  2. Consultar expertos antes de implementar ahorra semanas de trabajo

  No soy experto en todo, y no pretendo serlo. Pero sé dónde encontrar a quienes sí lo son. Unas horas investigando documentación oficial, foros especializados y casos de uso de empresas exitosas me ahorraron semanas de trabajo y deuda técnica.

  3. PostgreSQL RLS es subestimado

  Es una feature poderosa que pocas personas conocen. Proporciona aislamiento a nivel de base de datos sin la complejidad operacional de múltiples DBs.

  4. Diseña para la migración futura

  La arquitectura que elegí permite migrar a subdominios (cliente1.hostelos.app) con un cambio de 5 líneas de código. El tenant_id es el mismo, solo cambia cómo lo resolvemos.

  ---
  ¿Qué Sigue?

  Este artículo documentó la decisión arquitectónica. Si te interesa conocer los detalles de la implementación real —los bugs que encontré, los edge cases que no anticipé, y las métricas de performance antes/después— déjame un comentario y escribo un segundo artículo con todo el proceso técnico.

  ---
  ¿Preguntas o experiencias similares? Conectemos en https://linkedin.com/in/founder-journey o sígueme en https://founderjourney.com donde documento el proceso de construir SaaS en público.

  ---

  ## POST LINKEDIN (Markdown)

  ```markdown
  3 estrategias de multi-tenancy.
  1 decisión correcta.
  0 margen de error con clientes esperando.

  Así evalué la arquitectura para escalar mi SaaS:

  ❌ Database per tenant
     → Suena bien hasta que tienes 50 clientes
     → 50 DBs = 50 migraciones = nightmare

  ❌ Schema per tenant
     → Mejor, pero connection pooling limitado
     → Solo PostgreSQL

  ✅ Shared DB + Row-Level Security
     → Una DB, una migración, costos fijos
     → PostgreSQL filtra automáticamente por tenant
     → Usado por: Notion, Linear, Supabase

  Antes de implementar, consulté documentación oficial de PostgreSQL, foros de arquitectos y casos de empresas que ya escalaron.

  Lo que descubrí me hizo cambiar mi decisión inicial por completo.

  El costo de haber elegido mal:
  $500/mes vs $25/mes a escala de 50 clientes.

  La lección:
  No necesitas ser experto en todo.
  Necesitas saber dónde encontrar a quienes sí lo son.

  Unas horas investigando > semanas refactorizando.

  ¿Qué patrón de multi-tenancy usas en tu SaaS?

  ---

  #SaaS #PostgreSQL #Architecture #FullStack #TechLeadership

  ---
  Notas de Publicación

  Para el Blog:
  - Título SEO: Cómo Elegí la Arquitectura Multi-Tenant para HostelOS: El Camino de Database-per-Tenant a Row-Level Security
  - Meta description: Documenté mi proceso de evaluación de 3 estrategias multi-tenant para HostelOS. La decisión "obvia" estaba equivocada. Aquí está el análisis completo.
  - Tags sugeridos: multi-tenant, postgresql, rls, saas, architecture, building-in-public

  Para LinkedIn:
  - Publicar entre 8-10 AM
  - Link al blog en primer comentario (no en el post)
  - Responder comentarios en las primeras 2 horas

  ---